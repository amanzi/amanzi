/*
  Copyright 2010-202x held jointly by participating institutions.
  Amanzi is released under the three-clause BSD License.
  The terms of use and "as is" disclaimer for this license are
  provided in the top-level COPYRIGHT file.

  Authors: Konstantin Lipnikov
*/

/*
  This is the mpc_pk component of the Amanzi code.

  Process kernel that couples Transport in matrix and fracture
  using implicit scheme.
*/

#include "InverseFactory.hh"
#include "PDE_CouplingFlux.hh"
#include "PDE_DiffusionFracturedMatrix.hh"
#include "TransportImplicit_PK.hh"
#include "TreeOperator.hh"
#include "UniqueLocalIndex.hh"

#include "TransportMatrixFractureImplicit_PK.hh"

namespace Amanzi {

using CV_t = CompositeVector;
using CVS_t = CompositeVectorSpace;

/* *******************************************************************
* Constructor
******************************************************************* */
TransportMatrixFractureImplicit_PK::TransportMatrixFractureImplicit_PK(
  Teuchos::ParameterList& pk_tree,
  const Teuchos::RCP<Teuchos::ParameterList>& glist,
  const Teuchos::RCP<State>& S,
  const Teuchos::RCP<TreeVector>& soln)
  : Amanzi::PK_MPC<PK_BDF>(pk_tree, glist, S, soln),
    Amanzi::PK_MPCStrong<PK_BDF>(pk_tree, glist, S, soln),
    glist_(glist),
    soln_(soln)
{
  std::string pk_name = pk_tree.name();
  auto found = pk_name.rfind("->");
  if (found != std::string::npos) pk_name.erase(0, found + 2);

  // We need the flow list
  auto pk_list = Teuchos::sublist(glist, "PKs", true);
  tp_list_ = Teuchos::sublist(pk_list, pk_name, true);

  vo_ = Teuchos::rcp(new VerboseObject("TranCoupledImplicit_PK", *tp_list_));
}


/* *******************************************************************
* Physics-based setup of PK.
******************************************************************* */
void
TransportMatrixFractureImplicit_PK::Setup()
{
  mesh_domain_ = S_->GetMesh();
  mesh_fracture_ = S_->GetMesh("fracture");

  matrix_vol_flowrate_key_ = "volumetric_flow_rate";
  fracture_vol_flowrate_key_ = "fracture-volumetric_flow_rate";

  // primary and secondary fields for matrix affected by non-uniform
  // distribution of DOFs

  // -- darcy flux in matrix
  if (!S_->HasRecord(matrix_vol_flowrate_key_)) {
    auto cvs = Operators::CreateFracturedMatrixCVS(mesh_domain_, mesh_fracture_);
    auto mmap = cvs->Map("face", false);
    auto gmap = cvs->Map("face", true);
    S_->Require<CV_t, CVS_t>(matrix_vol_flowrate_key_, Tags::DEFAULT, "state")
      .SetMesh(mesh_domain_)
      ->SetGhosted(true)
      ->SetComponent("face", AmanziMesh::Entity_kind::FACE, mmap, gmap, 1);
  }

  // -- darcy flux in fracture
  if (!S_->HasRecord(fracture_vol_flowrate_key_)) {
    auto cvs = Operators::CreateManifoldCVS(mesh_fracture_);
    *S_->Require<CV_t, CVS_t>(fracture_vol_flowrate_key_, Tags::DEFAULT, "state")
       .SetMesh(mesh_fracture_)
       ->SetGhosted(true) = *cvs;
  }

  S_->Require<CV_t, CVS_t>(
      "fracture-solute_diffusion_to_matrix", Tags::DEFAULT, "fracture-solute_diffusion_to_matrix")
    .SetMesh(mesh_fracture_)
    ->SetGhosted(true)
    ->SetComponent("cell", AmanziMesh::Entity_kind::CELL, 2);
  S_->RequireEvaluator("fracture-solute_diffusion_to_matrix", Tags::DEFAULT);

  // process other PKs
  PK_MPCStrong<PK_BDF>::Setup();
}


/* *******************************************************************
* Initialization creates a tree operator to assemble global matrix
******************************************************************* */
void
TransportMatrixFractureImplicit_PK::Initialize()
{
  PK_MPCStrong<PK_BDF>::Initialize();

  // set a huge time step that will be limited by advance step
  set_dt(1e+98);

  TimestepControllerFactory<TreeVector> factory;
  auto ts_list = tp_list_->sublist("time integrator").sublist("BDF1");
  ts_control_ = factory.Create(ts_list, Teuchos::null, Teuchos::null);

  // diagonal blocks in tree operator are the Transport Implicit PKs
  pk_matrix_ = Teuchos::rcp_dynamic_cast<Transport::TransportImplicit_PK>(sub_pks_[0]);
  pk_fracture_ = Teuchos::rcp_dynamic_cast<Transport::TransportImplicit_PK>(sub_pks_[1]);
  AMANZI_ASSERT(pk_matrix_->domain() == "domain");

  int ntime;
  pk_matrix_->get_discretization_order(&nspace_m_, &ntime);
  pk_fracture_->get_discretization_order(&nspace_f_, &ntime);
  bool flag_ho = (nspace_m_ == 2 && nspace_f_ == 2);

  auto tvs = Teuchos::rcp(new TreeVectorSpace());
  tvs->PushBack(Teuchos::rcp(new TreeVectorSpace(pk_matrix_->op()->get_row_map())));
  tvs->PushBack(Teuchos::rcp(new TreeVectorSpace(pk_fracture_->op()->get_row_map())));
  op_tree_matrix_ = Teuchos::rcp(new Operators::TreeOperator(tvs));

  auto op0 = pk_matrix_->op()->Clone();
  auto op1 = pk_fracture_->op()->Clone();
  op_tree_matrix_->set_operator_block(0, 0, op0);
  op_tree_matrix_->set_operator_block(1, 1, op1);

  // off-diagonal blocks represent coupling terms
  fia_ = Teuchos::rcp(new FractureInsertion(mesh_domain_, mesh_fracture_));
  fia_->InitMatrixCellToFractureCell();

  // -- advection
  Teuchos::ParameterList oplist;

  op_coupling00_ = Teuchos::rcp(new Operators::PDE_CouplingFlux(oplist,
                                                                fia_->get_cvs_matrix(),
                                                                fia_->get_cvs_matrix(),
                                                                fia_->get_inds_matrix(),
                                                                fia_->get_inds_matrix(),
                                                                (!flag_ho) ? op0 : Teuchos::null));
  op_coupling00_->Setup(fia_->get_values(), 1.0);
  op_coupling00_->UpdateMatrices(Teuchos::null, Teuchos::null);

  op_coupling01_ = Teuchos::rcp(new Operators::PDE_CouplingFlux(oplist,
                                                                fia_->get_cvs_matrix(),
                                                                fia_->get_cvs_fracture(),
                                                                fia_->get_inds_matrix(),
                                                                fia_->get_inds_fracture()));
  op_coupling01_->Setup(fia_->get_values(), -1.0);
  op_coupling01_->UpdateMatrices(Teuchos::null, Teuchos::null);

  op_coupling10_ = Teuchos::rcp(new Operators::PDE_CouplingFlux(oplist,
                                                                fia_->get_cvs_fracture(),
                                                                fia_->get_cvs_matrix(),
                                                                fia_->get_inds_fracture(),
                                                                fia_->get_inds_matrix()));
  op_coupling10_->Setup(fia_->get_values(), -1.0);
  op_coupling10_->UpdateMatrices(Teuchos::null, Teuchos::null);

  op_coupling11_ = Teuchos::rcp(new Operators::PDE_CouplingFlux(oplist,
                                                                fia_->get_cvs_fracture(),
                                                                fia_->get_cvs_fracture(),
                                                                fia_->get_inds_fracture(),
                                                                fia_->get_inds_fracture(),
                                                                (!flag_ho) ? op1 : Teuchos::null));
  op_coupling11_->Setup(fia_->get_values(), 1.0);
  op_coupling11_->UpdateMatrices(Teuchos::null, Teuchos::null);

  op_tree_matrix_->set_operator_block(0, 1, op_coupling01_->global_operator());
  op_tree_matrix_->set_operator_block(1, 0, op_coupling10_->global_operator());

  // -- dispersion/diffusion
  flag_dispersion_ = false;
  for (const auto& pk : sub_pks_) {
    flag_dispersion_ |=
      Teuchos::rcp_dynamic_cast<Transport::Transport_PK>(pk)->get_flag_dispersion();
  }

  if (flag_dispersion_) {
    auto& cvs0 = pk_matrix_->op()->get_domain_map();
    auto mmap = cvs0->Map("face", false);
    auto gmap = cvs0->Map("face", true);

    fid_ = Teuchos::rcp(new FractureInsertion(mesh_domain_, mesh_fracture_));
    fid_->InitMatrixFaceToFractureCell(mmap, gmap);

    op_coupling00d_ =
      Teuchos::rcp(new Operators::PDE_CouplingFlux(oplist,
                                                   fid_->get_cvs_matrix(),
                                                   fid_->get_cvs_matrix(),
                                                   fid_->get_inds_matrix(),
                                                   fid_->get_inds_matrix(),
                                                   (!flag_ho) ? op0 : Teuchos::null));
    op_coupling00d_->Setup(fid_->get_values(), 1.0);
    op_coupling00d_->UpdateMatrices(Teuchos::null, Teuchos::null);

    op_coupling01d_ = Teuchos::rcp(new Operators::PDE_CouplingFlux(
      oplist,
      fid_->get_cvs_matrix(),
      fid_->get_cvs_fracture(),
      fid_->get_inds_matrix(),
      fid_->get_inds_fracture(),
      (!flag_ho) ? op_coupling01_->global_operator() : Teuchos::null));
    op_coupling01d_->Setup(fid_->get_values(), -1.0);
    op_coupling01d_->UpdateMatrices(Teuchos::null, Teuchos::null);

    op_coupling10d_ = Teuchos::rcp(new Operators::PDE_CouplingFlux(
      oplist,
      fid_->get_cvs_fracture(),
      fid_->get_cvs_matrix(),
      fid_->get_inds_fracture(),
      fid_->get_inds_matrix(),
      (!flag_ho) ? op_coupling10_->global_operator() : Teuchos::null));
    op_coupling10d_->Setup(fid_->get_values(), -1.0);
    op_coupling10d_->UpdateMatrices(Teuchos::null, Teuchos::null);

    op_coupling11d_ =
      Teuchos::rcp(new Operators::PDE_CouplingFlux(oplist,
                                                   fid_->get_cvs_fracture(),
                                                   fid_->get_cvs_fracture(),
                                                   fid_->get_inds_fracture(),
                                                   fid_->get_inds_fracture(),
                                                   (!flag_ho) ? op1 : Teuchos::null));
    op_coupling11d_->Setup(fid_->get_values(), 1.0);
    op_coupling11d_->UpdateMatrices(Teuchos::null, Teuchos::null);
  }

  // create a global problem
  pk_matrix_->op_adv()->ApplyBCs(true, true, true);
  pk_fracture_->op_adv()->ApplyBCs(true, true, true);

  Teuchos::ParameterList& ti_list = tp_list_->sublist("time integrator");
  std::string name = ti_list.get<std::string>("preconditioner", "Hypre AMG");
  std::string ls_name = ti_list.get<std::string>("linear solver", "GMRES with Hypre AMG");
  auto inv_list = AmanziSolvers::mergePreconditionerSolverLists(
    name, glist_->sublist("preconditioners"), ls_name, glist_->sublist("solvers"), true);
  inv_list.setName(name);
  op_tree_matrix_->set_inverse_parameters(inv_list);
  op_tree_matrix_->InitializeInverse();

  // time integrators
  if (nspace_m_ == 2 && nspace_f_ == 2) {
    Teuchos::ParameterList& bdf1_list = ti_list.sublist("BDF1");
    bdf1_dae_ = Teuchos::rcp(new BDF1_TI<TreeVector, TreeVectorSpace>(*this, bdf1_list, soln_));
  }

  // Test SPD properties of the matrix.
  // VerificationTV ver(op_tree_);
  // ver.CheckMatrixSPD();
  if (vo_->getVerbLevel() >= Teuchos::VERB_MEDIUM) {
    Teuchos::OSTab tab = vo_->getOSTab();
    *vo_->os() << "matrix:" << std::endl
               << op_tree_matrix_->PrintDiagnostics() << std::endl
               << vo_->color("green") << "Initialization of PK is complete." << vo_->reset()
               << std::endl
               << std::endl;
  }
}


/* *******************************************************************
* Maybe we need a separate PK instead of the if-clause
******************************************************************* */
bool
TransportMatrixFractureImplicit_PK::AdvanceStep(double t_old, double t_new, bool reinit)
{
  bool fail(false);

  num_aqueous_ = pk_matrix_->total_component_concentration()->ViewComponent("cell")->NumVectors();

  fia_->SetValues(S_->Get<CV_t>(matrix_vol_flowrate_key_));

  // fork between low-order and high-order
  int tot_itrs;
  if (nspace_m_ == 1 && nspace_f_ == 1) {
    fail = AdvanceStepLO_(t_old, t_new, &tot_itrs);
  } else if (nspace_m_ == 2 && nspace_f_ == 2) {
    fail = AdvanceStepHO_(t_old, t_new, &tot_itrs);
  } else {
    AMANZI_ASSERT(false);
  }

  if (fail) {
    Teuchos::OSTab tab = vo_->getOSTab();
    *vo_->os() << "Step failed, but no need to recover primary fields" << std::endl;
  }

  // output
  double dt = t_new - t_old;
  if (vo_->getVerbLevel() >= Teuchos::VERB_HIGH) {
    double sol_norm;
    pk_fracture_->total_component_concentration()->Norm2(&sol_norm);

    Teuchos::OSTab tab = vo_->getOSTab();
    *vo_->os() << "coupled solver: ||sol_f||=" << sol_norm
               << "  avg itrs=" << tot_itrs / num_aqueous_ << " dt=" << dt << std::endl;
  }

  if (vo_->getVerbLevel() >= Teuchos::VERB_MEDIUM) {
    auto tcc_m = pk_matrix_->total_component_concentration();
    auto tcc_f = pk_fracture_->total_component_concentration();

    Teuchos::OSTab tab = vo_->getOSTab();
    pk_matrix_->VV_PrintSoluteExtrema(*tcc_m->ViewComponent("cell"), dt, " (m)");
    pk_fracture_->VV_PrintSoluteExtrema(*tcc_f->ViewComponent("cell"), dt, " (f)");
  }

  return fail;
}


/* *******************************************************************
* One time step for aqueous components only
******************************************************************* */
bool
TransportMatrixFractureImplicit_PK::AdvanceStepLO_(double t_old, double t_new, int* tot_itrs)
{
  auto& tcc_m = *pk_matrix_->total_component_concentration();
  auto& tcc_f = *pk_fracture_->total_component_concentration();

  *tot_itrs = 0;
  for (int i = 0; i < num_aqueous_; i++) {
    pk_matrix_->UpdateLinearSystem(t_old, t_new, i);
    pk_fracture_->UpdateLinearSystem(t_old, t_new, i);

    op_coupling00_->Setup(fia_->get_values(), 1.0);
    op_coupling00_->UpdateMatrices(Teuchos::null, Teuchos::null);

    op_coupling01_->Setup(fia_->get_values2(), -1.0);
    op_coupling01_->UpdateMatrices(Teuchos::null, Teuchos::null);

    op_coupling10_->Setup(fia_->get_values(), -1.0);
    op_coupling10_->UpdateMatrices(Teuchos::null, Teuchos::null);

    op_coupling11_->Setup(fia_->get_values2(), 1.0);
    op_coupling11_->UpdateMatrices(Teuchos::null, Teuchos::null);

    // assemble dispersion/diffusion operators
    if (flag_dispersion_) {
      const auto& kn = *S_->Get<CV_t>("fracture-solute_diffusion_to_matrix").ViewComponent("cell");
      fid_->SetValues(kn, 1.0);

      op_coupling00d_->Setup(fid_->get_values(), 1.0);
      op_coupling00d_->UpdateMatrices(Teuchos::null, Teuchos::null);

      op_coupling01d_->Setup(fid_->get_values(), -1.0);
      op_coupling01d_->UpdateMatrices(Teuchos::null, Teuchos::null);

      op_coupling10d_->Setup(fid_->get_values(), -1.0);
      op_coupling10d_->UpdateMatrices(Teuchos::null, Teuchos::null);

      op_coupling11d_->Setup(fid_->get_values(), 1.0);
      op_coupling11d_->UpdateMatrices(Teuchos::null, Teuchos::null);
    }

    // create solver
    op_tree_matrix_->AssembleMatrix();
    op_tree_matrix_->ComputeInverse();

    auto& tvs = op_tree_matrix_->DomainMap();
    TreeVector rhs_one(tvs), sol_one(tvs);
    *rhs_one.SubVector(0)->Data() = *pk_matrix_->op()->rhs();
    *rhs_one.SubVector(1)->Data() = *pk_fracture_->op()->rhs();

    // solver for component i
    int ierr = op_tree_matrix_->ApplyInverse(rhs_one, sol_one);
    *tot_itrs += op_tree_matrix_->num_itrs();

    *(*tcc_m.ViewComponent("cell"))(i) = *(*sol_one.SubVector(0)->Data()->ViewComponent("cell"))(0);
    *(*tcc_f.ViewComponent("cell"))(i) = *(*sol_one.SubVector(1)->Data()->ViewComponent("cell"))(0);

    bool fail = (ierr != 0);
    if (fail) {
      dt_ = ts_control_->get_timestep(dt_, -1);
      return fail;
    }
  }

  dt_ = ts_control_->get_timestep(dt_, 1);
  return false;
}


/* *******************************************************************
*
******************************************************************* */
bool
TransportMatrixFractureImplicit_PK::AdvanceStepHO_(double t_old, double t_new, int* tot_itrs)
{
  double dt_next;

  dt_ = t_new - t_old;
  *tot_itrs = bdf1_dae_->number_nonlinear_steps();

  auto tcc_m = pk_matrix_->total_component_concentration();
  auto tcc_f = pk_fracture_->total_component_concentration();

  num_aqueous_ = tcc_m->ViewComponent("cell")->NumVectors();
  AMANZI_ASSERT(num_aqueous_ == 1);

  for (int i = 0; i < num_aqueous_; i++) {
    pk_matrix_->set_current_component(i);
    pk_fracture_->set_current_component(i);

    *soln_->SubVector(0)->Data() = *tcc_m;
    *soln_->SubVector(1)->Data() = *tcc_f;

    bool fail = bdf1_dae_->TimeStep(dt_, dt_next, soln_);
    dt_ = dt_next;
    if (fail) return fail;
  }

  *tcc_m = *soln_->SubVector(0)->Data();
  *tcc_f = *soln_->SubVector(1)->Data();

  bdf1_dae_->CommitSolution(dt_, soln_);
  *tot_itrs = bdf1_dae_->number_nonlinear_steps() - *tot_itrs;

  return false;
}


/* *******************************************************************
* Modify defualt behavior:
******************************************************************* */
void
TransportMatrixFractureImplicit_PK::CalculateDiagnostics(const Tag& tag)
{
  if (nspace_m_ == 2 && nspace_f_ == 2) { PK_MPCStrong<PK_BDF>::CalculateDiagnostics(tag); }
}


/* *******************************************************************
* Residual evaluation
******************************************************************* */
void
TransportMatrixFractureImplicit_PK::FunctionalResidual(double t_old,
                                                       double t_new,
                                                       Teuchos::RCP<TreeVector> u_old,
                                                       Teuchos::RCP<TreeVector> u_new,
                                                       Teuchos::RCP<TreeVector> f)
{
  PK_MPCStrong<PK_BDF>::FunctionalResidual(t_old, t_new, u_old, u_new, f);

  // contribution from coupling terms
  auto u0 = u_new->SubVector(0)->Data();
  auto u1 = u_new->SubVector(1)->Data();

  auto f0 = f->SubVector(0)->Data();
  auto f1 = f->SubVector(1)->Data();

  op_coupling00_->Setup(fia_->get_values(), 1.0);
  op_coupling00_->global_operator()->Apply(*u0, *f0, 1.0);

  op_coupling01_->Setup(fia_->get_values2(), -1.0);
  op_coupling01_->global_operator()->Apply(*u1, *f0, 1.0);

  op_coupling10_->Setup(fia_->get_values(), -1.0);
  op_coupling10_->global_operator()->Apply(*u0, *f1, 1.0);

  op_coupling11_->Setup(fia_->get_values2(), 1.0);
  op_coupling11_->global_operator()->Apply(*u1, *f1, 1.0);

  if (flag_dispersion_) {
    const auto& kn = *S_->Get<CV_t>("fracture-solute_diffusion_to_matrix").ViewComponent("cell");
    fid_->SetValues(kn, 1.0);

    op_coupling00d_->Setup(fid_->get_values(), 1.0);
    op_coupling00d_->global_operator()->Apply(*u0, *f0, 1.0);

    op_coupling01d_->Setup(fid_->get_values(), -1.0);
    op_coupling01d_->global_operator()->Apply(*u1, *f0, 1.0);

    op_coupling10d_->Setup(fid_->get_values(), -1.0);
    op_coupling10d_->global_operator()->Apply(*u0, *f1, 1.0);

    op_coupling11d_->Setup(fid_->get_values(), 1.0);
    op_coupling11d_->global_operator()->Apply(*u1, *f1, 1.0);
  }
}


/* ******************************************************************
* Recompute preconditioner
****************************************************************** */
void
TransportMatrixFractureImplicit_PK::UpdatePreconditioner(double tp,
                                                         Teuchos::RCP<const TreeVector> u,
                                                         double dtp)
{
  PK_MPCStrong<PK_BDF>::UpdatePreconditioner(tp, u, dtp);
}


/* ******************************************************************
* Apply block-diagonal preconditioner inv(B) * X.
****************************************************************** */
int
TransportMatrixFractureImplicit_PK::ApplyPreconditioner(Teuchos::RCP<const TreeVector> X,
                                                        Teuchos::RCP<TreeVector> Y)
{
  return PK_MPCStrong<PK_BDF>::ApplyPreconditioner(X, Y);
  // return op_pc_solver_->ApplyInverse(*X, *Y);
}

} // namespace Amanzi
